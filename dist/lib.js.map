{"version":3,"file":null,"sources":["../lib/copy.js","../lib/compare.js","../lib/merge.js"],"sourcesContent":["function copy(obj) {\n  let clone;\n\n  // Return literals.\n  if (!(obj instanceof Object)) return obj;\n\n  // Create clone object with proper params.\n  const Constructor = obj.constructor;\n  switch (Constructor) {\n    case Date:\n    case Map:\n    case Set:\n    case RegExp:\n      clone = new Constructor(obj);\n      break;\n    case Promise:\n      clone = new Constructor((resolve, reject) => {\n        resolve(obj.then);\n        reject(obj.catch);\n      });\n      break;\n    // case WeakMap:\n    // case WeakSet:\n    default:\n      clone = new Constructor();\n  }\n\n  // Copy each property.\n  for (const property in obj) {\n    if (Object.hasOwnProperty.call(obj, property)) {\n      clone[property] = copy(obj[property]);\n    }\n  }\n\n  return clone;\n}\n\nexport default copy;\n","// Check for objects that allow string comparisons.\nfunction checkInstance(a, b) {\n  return (a instanceof Date && b instanceof Date) ||\n    (a instanceof RegExp && b instanceof RegExp) ||\n    (a instanceof String && b instanceof String) ||\n    (a instanceof Number && b instanceof Number);\n}\n\n// Check if a is a Map or a Set.\nfunction isMapSet(a) {\n  return a.constructor === Map || a.constructor === Set;\n}\n\n// Compare Maps and Sets.\nfunction checkMapSet(a, b) {\n  if (a.size !== b.size) return false;\n  for (const item of b) {\n    if (a.constructor === Map) {\n      const [key, val] = item;\n      if (!a.has(key)) return false;\n      if (a.get(key) !== val) return false;\n    } else if (!a.has(item)) return false;\n  }\n  return true;\n}\n\nfunction isPrototype(a, b) {\n  return Object.isPrototypeOf.call(a, b) || Object.isPrototypeOf.call(b, a);\n}\n\nfunction compare(a, b) {\n\n  // Check same literal value or same object reference.\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n\n  // Check types and short-circit on non-objects.\n  const type = typeof(a);\n  if (type !== typeof(b)) return false;\n  if (type === 'number' && isNaN(a) && isNaN(b)) return true;\n  if (type !== 'object') return a === b;\n  if (checkInstance(a, b)) return a.toString() === b.toString();\n\n  // Check object equivalence.\n  if (isPrototype(a, b)) return false;\n  if (a.constructor !== b.constructor) return false;\n  if (isMapSet(a) && !checkMapSet(a, b)) return false;\n  if (a.prototype !== b.prototype) return false;\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (const property in a) {\n    if (!compare(a[property], b[property])) return false;\n  }\n\n  // Must be the same.\n  return true;\n}\n\nexport default compare;\n","import compare from './compare';\n\nconst constructors = [Date, RegExp, String, Number, Map, WeakMap, Set, WeakSet, Promise];\n\nfunction merge(a, b) {\n  if (!(a instanceof Object) || !(b instanceof Object)) {\n    throw new TypeError('You can only merge objects.');\n  }\n  for (const property in b) {\n    if (Object.hasOwnProperty.call(b, property)) {\n      const oldProp = a[property];\n      const newProp = b[property];\n      if (!compare(oldProp, newProp)) {\n        if (newProp === undefined) {\n          delete a[property];\n        } else if (newProp === null) {\n          a[property] = null;\n        // Node requires the ._c for Sets and Maps.\n        } else if (constructors.indexOf(newProp.constructor) !== -1 || !!newProp._c) {\n          a[property] = newProp;\n        } else if (newProp instanceof Object && oldProp instanceof Object) {\n          merge(oldProp, newProp);\n        } else {\n          a[property] = newProp;\n        }\n      }\n    }\n  }\n}\n\nexport default merge;\n"],"names":["copy","obj","clone","Object","Constructor","constructor","Date","Map","Set","RegExp","Promise","resolve","reject","then","catch","property","hasOwnProperty","call","checkInstance","a","b","String","Number","isMapSet","checkMapSet","size","item","key","val","has","get","isPrototype","isPrototypeOf","compare","type","isNaN","toString","prototype","keys","length","merge","TypeError","oldProp","newProp","undefined","constructors","indexOf","_c","WeakMap","WeakSet"],"mappings":"gMAAA,SAASA,GAAKC,MACRC,eAGED,YAAeE,SAAS,MAAOF,MAG/BG,GAAcH,EAAII,mBAChBD,OACDE,UACAC,SACAC,SACAC,UACK,GAAIL,GAAYH,aAErBS,WACK,GAAIN,GAAY,SAACO,EAASC,KACxBX,EAAIY,QACLZ,EAAIa,yBAML,GAAIV,OAIX,GAAMW,KAAYd,GACjBE,OAAOa,eAAeC,KAAKhB,EAAKc,OAC5BA,GAAYf,EAAKC,EAAIc,WAIxBb,GCjCT,QAASgB,GAAcC,EAAGC,SAChBD,aAAab,OAAQc,YAAad,OACvCa,YAAaV,SAAUW,YAAaX,SACpCU,YAAaE,SAAUD,YAAaC,SACpCF,YAAaG,SAAUF,YAAaE,QAIzC,QAASC,GAASJ,SACTA,GAAEd,cAAgBE,KAAOY,EAAEd,cAAgBG,IAIpD,QAASgB,GAAYL,EAAGC,MAClBD,EAAEM,OAASL,EAAEK,KAAM,OAAO,yCACXL,iDAAG,IAAXM,cACLP,EAAEd,cAAgBE,IAAK,SACNmB,KAAZC,OAAKC,WACPT,EAAEU,IAAIF,GAAM,OAAO,KACpBR,EAAEW,IAAIH,KAASC,EAAK,OAAO,MAC1B,KAAKT,EAAEU,IAAIH,GAAO,OAAO,uFAE3B,EAGT,QAASK,GAAYZ,EAAGC,SACfjB,QAAO6B,cAAcf,KAAKE,EAAGC,IAAMjB,OAAO6B,cAAcf,KAAKG,EAAGD,GAGzE,QAASc,GAAQd,EAAGC,MAGdD,IAAMC,EAAG,OAAO,KACV,OAAND,GAAoB,OAANC,EAAY,OAAO,KAG/Bc,sBAAcf,iBAAAA,MAChBe,wBAAgBd,iBAAAA,IAAI,OAAO,KAClB,WAATc,GAAqBC,MAAMhB,IAAMgB,MAAMf,GAAI,OAAO,KACzC,WAATc,EAAmB,MAAOf,KAAMC,KAChCF,EAAcC,EAAGC,GAAI,MAAOD,GAAEiB,aAAehB,EAAEgB,cAG/CL,EAAYZ,EAAGC,GAAI,OAAO,KAC1BD,EAAEd,cAAgBe,EAAEf,YAAa,OAAO,KACxCkB,EAASJ,KAAOK,EAAYL,EAAGC,GAAI,OAAO,KAC1CD,EAAEkB,YAAcjB,EAAEiB,UAAW,OAAO,KACpClC,OAAOmC,KAAKnB,GAAGoB,SAAWpC,OAAOmC,KAAKlB,GAAGmB,OAAQ,OAAO,MACvD,GAAMxB,KAAYI,OAChBc,EAAQd,EAAEJ,GAAWK,EAAEL,IAAY,OAAO,SAI1C,EClDT,QAASyB,GAAMrB,EAAGC,QACVD,YAAahB,SAAaiB,YAAajB,cACrC,IAAIsC,WAAU,mCAEjB,GAAM1B,KAAYK,MACjBjB,OAAOa,eAAeC,KAAKG,EAAGL,GAAW,IACrC2B,GAAUvB,EAAEJ,GACZ4B,EAAUvB,EAAEL,EACbkB,GAAQS,EAASC,KACJC,SAAZD,QACKxB,GAAEJ,GACY,OAAZ4B,IACP5B,GAAY,KAEL8B,EAAaC,QAAQH,EAAQtC,gBAAiB,GAAQsC,EAAQI,KACrEhC,GAAY4B,EACLA,YAAmBxC,SAAUuC,YAAmBvC,UACnDuC,EAASC,KAEb5B,GAAY4B,0nBArBlBE,GAAgBvC,KAAMG,OAAQY,OAAQC,OAAQf,IAAKyC,QAASxC,IAAKyC,QAASvC"}