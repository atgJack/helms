{"version":3,"file":null,"sources":["../lib/copy.js","../lib/compare.js","../lib/merge.js"],"sourcesContent":["function copy(obj) {\r\n  let clone;\r\n\r\n  // Return literals.\r\n  if (!(obj instanceof Object)) return obj;\r\n\r\n  // Create clone object with proper params.\r\n  const Constructor = obj.constructor;\r\n  switch (Constructor) {\r\n    case Date:\r\n    case RegExp:\r\n      clone = new Constructor(obj);\r\n      break;\r\n    default:\r\n      clone = new Constructor();\r\n  }\r\n\r\n  // Copy each property.\r\n  for (let property in obj) clone[property] = copy(obj[property]);\r\n\r\n  return clone;\r\n}\r\n\r\nexport default copy\r\n","function compare(a, b) {\r\n\r\n  // Check same literal value or same object reference.\r\n  if (a === b) return true;\r\n  if (a === null || b === null) return false;\r\n\r\n  // Check types and short-circit on non-objects.\r\n  const type = typeof(a);\r\n  if (type !== typeof(b)) return false;\r\n  if (type === 'number' && isNaN(a) && isNaN(b)) return true;\r\n  if (type !== 'object') return a === b;\r\n  if (checkInstance(a,b)) return a.toString() === b.toString();\r\n\r\n  // Check object equivalence.\r\n  if (a.isPrototypeOf(b) || b.isPrototypeOf(a)) return false;\r\n  if (a.constructor !== b.constructor) return false;\r\n  if (a.prototype !== b.prototype) return false;\r\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\r\n  for (let property in a) {\r\n    if (!compare(a[property], b[property])) return false;\r\n  }\r\n\r\n  // Must be the same.\r\n  return true;\r\n}\r\n\r\n// Check for objects that allow string comparisons.\r\nfunction checkInstance(a,b) {\r\n  return (a instanceof Date && b instanceof Date) ||\r\n    (a instanceof RegExp && b instanceof RegExp) ||\r\n    (a instanceof String && b instanceof String) ||\r\n    (a instanceof Number && b instanceof Number)\r\n}\r\n\r\nexport default compare;\r\n","import compare from './compare'\r\nimport copy from './copy'\r\n\r\nconst constructors = [Date, RegExp, String, Number];\r\n\r\nfunction merge(a, b) {\r\n  if (!(a instanceof Object) || !(b instanceof Object))\r\n    throw new TypeError('You can only merge objects.');\r\n\r\n  for (let property in b) {\r\n    const oldProp = a[property];\r\n    const newProp = b[property];\r\n    if (compare(oldProp, newProp)) continue;\r\n    if (constructors.indexOf(newProp.constructor) !== -1) {\r\n      a[property] = newProp;\r\n    } else if (newProp instanceof Object && oldProp instanceof Object) {\r\n      merge(oldProp, newProp)\r\n    } else a[property] = newProp;\r\n  }\r\n}\r\n\r\nexport default merge;\r\n"],"names":["copy","obj","clone","Object","Constructor","constructor","Date","RegExp","property","compare","a","b","type","isNaN","checkInstance","toString","isPrototypeOf","prototype","keys","length","String","Number","merge","TypeError","oldProp","newProp","constructors","indexOf"],"mappings":"gMAAA,SAASA,GAAKC,MACRC,eAGED,YAAeE,SAAS,MAAOF,MAG/BG,GAAcH,EAAII,mBAChBD,OACDE,UACAC,UACK,GAAIH,GAAYH,mBAGhB,GAAIG,OAIX,GAAII,KAAYP,KAAWO,GAAYR,EAAKC,EAAIO,GAErD,OAAON,GCpBT,QAASO,GAAQC,EAAGC,MAGdD,IAAMC,EAAG,OAAO,KACV,OAAND,GAAoB,OAANC,EAAY,OAAO,KAG/BC,sBAAcF,iBAAAA,MAChBE,wBAAgBD,iBAAAA,IAAI,OAAO,KAClB,WAATC,GAAqBC,MAAMH,IAAMG,MAAMF,GAAI,OAAO,KACzC,WAATC,EAAmB,MAAOF,KAAMC,KAChCG,EAAcJ,EAAEC,GAAI,MAAOD,GAAEK,aAAeJ,EAAEI,cAG9CL,EAAEM,cAAcL,IAAMA,EAAEK,cAAcN,GAAI,OAAO,KACjDA,EAAEL,cAAgBM,EAAEN,YAAa,OAAO,KACxCK,EAAEO,YAAcN,EAAEM,UAAW,OAAO,KACpCd,OAAOe,KAAKR,GAAGS,SAAWhB,OAAOe,KAAKP,GAAGQ,OAAQ,OAAO,MACvD,GAAIX,KAAYE,OACdD,EAAQC,EAAEF,GAAWG,EAAEH,IAAY,OAAO,SAI1C,EAIT,QAASM,GAAcJ,EAAEC,SACfD,aAAaJ,OAAQK,YAAaL,OACvCI,YAAaH,SAAUI,YAAaJ,SACpCG,YAAaU,SAAUT,YAAaS,SACpCV,YAAaW,SAAUV,YAAaU,QC1BzC,QAASC,GAAMZ,EAAGC,QACVD,YAAaP,SAAaQ,YAAaR,SAC3C,KAAM,IAAIoB,WAAU,mCAEjB,GAAIf,KAAYG,GAAG,IAChBa,GAAUd,EAAEF,GACZiB,EAAUd,EAAEH,EACdC,GAAQe,EAASC,KACjBC,EAAaC,QAAQF,EAAQpB,gBAAiB,IAC9CG,GAAYiB,EACLA,YAAmBtB,SAAUqB,YAAmBrB,UACnDqB,EAASC,GACVf,EAAEF,GAAYiB,oNAdnBC,GAAgBpB,KAAMC,OAAQa,OAAQC"}